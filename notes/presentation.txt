-What are the main modules of your program? Why did you divide them up in this way?
    -Model.hs exposes some common types shared between the client and server. These are
    the types that represent our system.
    -Server.hs contains the core server logic, including the definition of server
    state and updating of state. It makes sense to keep this separate from Model
    because it shouldn't be exposed to clients.
    -ServerTesting.hs contains testing for the server.
    -Client.hs contains the client logic, which is again separate from Model so that
    it's not exposed to the server.
    -ClientTesting.hs contains some test cases for the client.

-Parts of code you're proud of
    -The terminal logic in the client. We thought that haskell wouldn't be good for
    such an imperative, low-level job but it still did pretty well and the result
    looks nice.
    -The generalization of the server logic to any monad and MonadSocket. Made
    testing the server possible and easy. Took a lot of time here to think about
    how the types work together.

-Talked about in class
    -State monad in server tester
    -state transformer
    -Uses of map and fold in server/server tester
    -Use of GADTs
    -parametric polymorphism
    -using type classes

-Scrap and redesign, what didn't work, hardest part to get right
    -Scrapped/redesigned parsing. Were going to use applicative parsing, but it seemed like overkill
    because our intermediate format was pretty simple.
    -What didn't work: working with sockets didn't work at first. Using Haskell's network API was
    unintuitive to us and we found it difficult to use sockets properly, or "The Haskell Way".
    -Hardest part to get correct: Generalizing server code in the type of monad. Thinking about
    the types was really hard, and it wasn't easy to think far enough in advance to know whether
    our initial design for the parametric functions was correct.

-Testing
    -Unit tests! See the two test files, the mock monad is sick.

-Additional features
    -Make the server distributed. This would be nice because it would make the server practical
    and it'd be interesting to see how this could be done in Haskell. We think you could do it
    by periodically emitting updates between servers to keep their states consistent and
    keep a list of known IPs for servers to connect to each other.

-Other language
    -Java for the server, and JS for a web client. Java has a mature concurrency library and
    its type system is still expressive enough to rule out common errors (i.e., we wouldn't
    want to do this backend in JS). All the imperative logic would be easier. The more
    difficult part may be mocking servers for testing - Java needs heavy libraries to do this.

-What did we learn?
    -How to do concurrent programming in Haskell
    -How to do low-level jobs (e.g. terminal coloring) in a _safe_ way in a high level language
    like Haskell
    -GADTs are very cool!
    -Haskell's strong type system lets us have a very flexible design, see monadsocket and friends